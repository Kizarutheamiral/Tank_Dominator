package com.dominator.game.Entities;

import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.*;
import com.dominator.game.Module.Intersection;
import com.dominator.game.Module.Pathfinder;
import com.dominator.game.Quadtree.Point;
import com.dominator.game.System.GameEventManager;
import com.sun.jnlp.IntegrationServiceImpl;


import java.util.ArrayList;

import static com.dominator.game.CONSTANT.step;


/**
 * Created by Choujaa Wassil on 21/02/2017.
 */
public strictfp abstract class Tank implements Dynamic_Bodies{

    Vector2 flowfield[][];
    protected float speed;
    public boolean moving = false;
    public ArrayList<Point> path;
    protected Body body;
    private Map map;
    public  Vector2 pathTarget;
    private final Vector2 direction = new Vector2(0f,0f);
    protected float rotationSpeed;
    private boolean selected = false;
    protected boolean follower = false;
    private Tank leader = null;

    public Tank(float speed,float rotationSpeed, Map map) {
        this.map = map;
        this.speed = speed;
        this.rotationSpeed = rotationSpeed;
    }

    protected void setupFriction(){
        body.setAngularDamping(10f);
        body.setLinearDamping(5f);

    }

    /// Movement
    public void move(){
        // if target is close to a given range just go straight else, use flowfield or A*
        if(follower){
            follow(leader);
        } else {
            follow_Path();
        }
    }

    public void setFlowfield(Vector2 update[][]){
        flowfield = update;
    }

    @Override
    public void follow_Flow_field() {
/*        Vector2 pos =  body.getPosition();
        int position = map.getGraph().findNearestNode((int) pos.x/Map.step,(int) pos.y/Map.step);
        //System.out.println(map.getGraph().getX(position)+" "+map.getGraph().getY(position));
        if(flowfield!=null && position!=-1){
            //body.applyLinearImpulse(new Vector2(1,1),new Vector2(0,0),true);
            Vector2 currentSpeed = body.getLinearVelocity();
            Vector2 direction =  new Vector2(flowfield[map.getGraph().getX(position)][map.getGraph().getY(position)]).nor();
            Vector2 appliedSpeed= new Vector2(direction.y*speed,direction.x*speed).sub(currentSpeed);
            rotate(direction);
           // System.out.println(appliedSpeed.x + " "+appliedSpeed.y + "pos :"+position.x+" "+position.y);

           body.applyLinearImpulse(appliedSpeed,body.getPosition(),true);


            applyFrottement();


        }*/
        // generated by Flow
    }

    public void follow_Path() {


        if (path != null){
            if (pathTarget == null){
                if(path.size() != 0){
                    pathTarget =  new Vector2(path.get(0).x, path.get(0).y);
                } else {
                    // break
                    body.setLinearVelocity(body.getLinearVelocity().scl(1/3f));
                    path = null;
                    return;
                }
            }


            Vector2 currentSpeed = body.getLinearVelocity();
            //System.out.println(currentSpeed+ " "+ pathTarget + " "+ body.getPosition());
            Vector2 velocity =  new Vector2().set(pathTarget.x-body.getPosition().x,pathTarget.y-body.getPosition().y);

            direction.set(velocity.nor());

            Vector2 appliedSpeed = new Vector2(body.getTransform().getOrientation().x*speed,body.getTransform().getOrientation().y*speed).sub(currentSpeed);


            if(rotate()){
                applySpeed(appliedSpeed);
            }

            if (isArrivedAtTarget(pathTarget,10f)){
                pathTarget = null;
                path.remove(0);
            }
        }


    }

    private void follow(Tank leader) {

        if(leader==null){
            follower=false;
            return;
        }

        if(path==null || path.size()==0){
            if(leader.pathTarget!=null){
                path=GameEventManager.instance().finder.AstarPathFrom(getX(),getY(),leader.pathTarget.x,leader.pathTarget.y);
            } else {
                path=GameEventManager.instance().finder.AstarPathFrom(getX(),getY(),leader.getX(),leader.getY());
            }
        }

        if(path==null){
            return;
        }

        pathTarget =  new Vector2(path.get(0).x, path.get(0).y);

        direction.set(pathTarget.x-body.getPosition().x,pathTarget.y-body.getPosition().y).nor();

        Vector2 currentSpeed = body.getLinearVelocity();

        Vector2 appliedSpeed = new Vector2(body.getTransform().getOrientation().x*speed,body.getTransform().getOrientation().y*speed).sub(currentSpeed);

        if(rotate()){
            applySpeed(appliedSpeed);
        }

        if (isArrivedAtTarget(pathTarget,step)){
            pathTarget = null;
            path.remove(0);
            if(leader.pathTarget==null && path.size()==0){
                path=null;
                follower=false;
                leader=null;
            }
        }
    }


    private void applySpeed(Vector2 appliedSpeed) {
        body.applyLinearImpulse(appliedSpeed,body.getWorldCenter(),false);
    }

    private boolean isArrivedAtTarget(Vector2 pathTarget, float range) {
        return Intersection.CircleIntesectsCircle(pathTarget.x,pathTarget.y,range,getX(),getY(),range);
    }

    @Override
    public void show(Batch batch) {
        if(selected){

        }
    }

    /// Attack

    public abstract void update();

    public abstract void attack();
    /// sandbox pattern
    protected void gatling_Cannon_Attack(){

    }

    protected void large_Calibre_Attack(){

    }

    public Vector2[][] getFlowfield() {
        return flowfield;
    }


    public abstract boolean rotate();

    public float getX() {
        return body.getPosition().x;
    }
    public float getY() {
        return body.getPosition().y;
    }
    public abstract float getHeight();
    public abstract float getWidth();

    public boolean contain(float x, float y) {

        for (Fixture fix: body.getFixtureList()) {
            if (fix.testPoint(x,y)){
                return true;
            }
        }
        return false;
    }


    public boolean intersect(float x, float y, float width, float height) {

        final Boolean[] found = {false};

        body.getWorld().QueryAABB(new QueryCallback() {
            @Override
            public boolean reportFixture(Fixture fixture) {
                found[0] =  body.getFixtureList().contains(fixture,false);
                return !found[0];
            }
        },x, y, x+width, y+height);

        return found[0];
    }

    public Vector2 getDirection() {
        return direction;
    }
    public void setSelected(boolean selected) {
        this.selected = selected;
    }
    public boolean isSelected() {
        return selected;
    }

    public void setLeader(Tank tank) {
        follower = true;
        leader = tank;
        path=null;
    }

    public void setPath(ArrayList<Point> newPath){
        path = newPath;
        pathTarget = null;
        follower=false;
    }

    public Vector2 getPosition() {
        return body.getPosition();
    }
}
