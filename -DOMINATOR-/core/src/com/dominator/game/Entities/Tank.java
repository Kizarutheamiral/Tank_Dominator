package com.dominator.game.Entities;

import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.Body;
import com.badlogic.gdx.physics.box2d.Manifold;
import com.badlogic.gdx.physics.box2d.Transform;
import com.dominator.game.Module.Intersection;
import com.dominator.game.Module.Pathfinder;
import com.dominator.game.Quadtree.Point;
import com.dominator.game.System.GameEventManager;
import com.sun.jnlp.IntegrationServiceImpl;


import java.util.ArrayList;


/**
 * Created by Choujaa Wassil on 21/02/2017.
 */
public strictfp abstract class Tank implements Dynamic_Bodies{

    Vector2 flowfield[][];
    protected float speed;
    public boolean moving = false;
    public ArrayList<Point> path;
    protected Body body;
    private Map map;
    public  Vector2 pathTarget;
    private final Vector2 direction = new Vector2(1f,1f);
    protected float rotationSpeed;
    public Tank(float speed,float rotationSpeed, Map map) {
        this.map = map;
        this.speed = speed;
        this.rotationSpeed = rotationSpeed;
    }

    protected void setupFriction(){
        body.setAngularDamping(10f);
        body.setLinearDamping(1f);
    }

    /// Movement
    public void move(boolean option){
        // if target is close to a given range just go straight else, use flowfield or A*
        if(option){
            follow_Flow_field();
        } else {
            follow_Path();
        }
    }

    public void setFlowfield(Vector2 update[][]){
        flowfield = update;
    }

    @Override
    public void follow_Flow_field() {
/*        Vector2 pos =  body.getPosition();
        int position = map.getGraph().findNearestNode((int) pos.x/Map.step,(int) pos.y/Map.step);
        //System.out.println(map.getGraph().getX(position)+" "+map.getGraph().getY(position));
        if(flowfield!=null && position!=-1){
            //body.applyLinearImpulse(new Vector2(1,1),new Vector2(0,0),true);
            Vector2 currentSpeed = body.getLinearVelocity();
            Vector2 direction =  new Vector2(flowfield[map.getGraph().getX(position)][map.getGraph().getY(position)]).nor();
            Vector2 appliedSpeed= new Vector2(direction.y*speed,direction.x*speed).sub(currentSpeed);
            rotate(direction);
           // System.out.println(appliedSpeed.x + " "+appliedSpeed.y + "pos :"+position.x+" "+position.y);

           body.applyLinearImpulse(appliedSpeed,body.getPosition(),true);


            applyFrottement();


        }*/
        // generated by Flow
    }

    public void follow_Path() {

        if (path != null){
            if (pathTarget == null){
                if(path.size() != 0){
                    pathTarget =  new Vector2(path.get(0).x, path.get(0).y);
                } else {
                    // break
                    body.setLinearVelocity(body.getLinearVelocity().scl(1/3f));
                    path = null;
                    return;
                }
            }


            Vector2 currentSpeed = body.getLinearVelocity();
            //System.out.println(currentSpeed+ " "+ pathTarget + " "+ body.getPosition());
            Vector2 velocity =  new Vector2().set(pathTarget.x-body.getPosition().x,pathTarget.y-body.getPosition().y);

            direction.set(velocity.nor());

            Vector2 appliedSpeed = new Vector2(body.getTransform().getOrientation().x*speed,body.getTransform().getOrientation().y*speed).sub(currentSpeed);


            if(rotate()){
                applySpeed(appliedSpeed);
            }

            if (isArrivedAtTarget(pathTarget)){
                pathTarget = null;
                path.remove(0);
            }
        }

        rotate();


        applyFriction();

    }

    private void applyFriction() {
/*        Vector2 velocity = body.getLinearVelocity();
        int len = Math.round(velocity.len());
        if(!(len <=1)){
            Vector2 vector2 = velocity.cpy().rotate(180f).scl(2f);
            applySpeed(vector2);
        }*/
    }

    private void applySpeed(Vector2 appliedSpeed) {
        body.applyLinearImpulse(appliedSpeed,body.getWorldCenter(),false);
    }

    private boolean isArrivedAtTarget(Vector2 pathTarget) {
        return Intersection.contain(pathTarget.x+10,pathTarget.y+10,getX(),getY(),getWidth(),getHeight()) ;
    }

    @Override
    public void show() {}

    /// Attack

    public abstract void update();

    public abstract void attack();
    /// sandbox pattern
    protected void gatling_Cannon_Attack(){

    }

    protected void large_Calibre_Attack(){

    }

    public Vector2[][] getFlowfield() {
        return flowfield;
    }


    public abstract boolean rotate();

    public float getX() {
        return body.getPosition().x;
    }
    public float getY() {
        return body.getPosition().y;
    }

    public abstract float getHeight();
    public abstract float getWidth();
    public abstract boolean contain(float x, float y);

    public void setPath(ArrayList<Point> newPath){
        path = newPath;
        pathTarget = null;
    }

    public Vector2 getDirection() {
        return direction;
    }
}
